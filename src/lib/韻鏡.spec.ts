import test from 'ava';

import { iter音韻地位 } from './資料';
import { 音韻地位 } from './音韻地位';
import { 音韻地位2韻鏡位置, 韻鏡位置 } from './韻鏡';

test('音韻地位與韻鏡位置可以互相轉換', t => {
  const skipList = [
    '日開三祭平', // 臡，特殊字無法處理（祭、平）
    '常開三祭平', // 栘，特殊字無法處理（祭、平）
    '溪開三B蒸平', // 硱，特殊字無法處理（蒸、!(幫組或合口)、B）
    '曉開三B幽平', // 烋，與「曉開三A幽平」無法區分
    '生開三鹽平', // 襳，韻鏡無法表示（鹽韻、韻鏡二等）
    '定開二佳上', // 箉，特殊字無法處理（定、二）
    '云合三C廢上', // 倄，特殊字無法處理（廢、上）
    '昌開三廢上', // 茝，特殊字無法處理（廢、上）
    '以開三廢上', // 佁，特殊字無法處理（廢、上）
    '明三A麻上', // 乜，特殊字無法處理（麻、A）
    '並三A陽上', // 𩦠，特殊字無法處理（陽、A）
    '端開二庚上', // 打，與「知開二庚上」無法區分
    '生合三祭去', // 𠻜，韻鏡無法表示（祭韻、韻鏡二等）
    '初合三祭去', // 㯔，韻鏡無法表示（祭韻、韻鏡二等）
    '生開三祭去', // 㡜，韻鏡無法表示（祭韻、韻鏡二等）
    '初合三元去', // 𣀔，韻鏡無法表示（元韻、韻鏡二等）
    '影開三B蒸入', // 抑，與「影開三C蒸入」無法區分
    '生開三鹽入', // 萐，韻鏡無法表示（鹽韻、韻鏡二等）
    '以開三嚴入', // 殜，韻鏡無法表示（嚴韻、韻鏡四等）
    // 莊組仙韻在下方處理，故此處無需處理
    // '崇開三仙平', // 潺，與「崇開二山平」（亦「潺」字）無法區分
    // '莊合三仙平', // 恮
    // '生合三仙平', // 栓
    // '崇合三仙上', // 撰，與「崇合二山上」（亦「撰」字）無法區分
    // '崇開三仙上', // 棧，與「崇開二山上」（亦「棧」字）無法區分
    // '生合三仙去', // 𨏉
    // '崇合三仙去', // 䉵
    // '莊合三仙去', // 孨
    // '生合三仙入', // 㕞
    // '莊合三仙入', // 茁
    // '生開三仙入', // 榝
    // '初合三仙入', // 㔍
    // '崇開三仙入', // 𨵊
  ];

  for (let 當前音韻地位 of iter音韻地位()) {
    if (skipList.includes(當前音韻地位.描述)) {
      continue;
    }

    let 當前韻鏡位置: 韻鏡位置;
    let recovered音韻地位: 音韻地位;

    try {
      當前韻鏡位置 = 音韻地位2韻鏡位置(當前音韻地位);
    } catch (e) {
      console.error(`Error when processing 音韻地位 ${當前音韻地位.描述}`);
      throw e;
    }

    try {
      recovered音韻地位 = 當前韻鏡位置.to音韻地位();
    } catch (e) {
      console.error(`Error when processing 音韻地位 ${當前音韻地位.描述} 韻鏡位置 ${當前韻鏡位置.描述}`);
      throw e;
    }

    // 莊組仙韻特殊處理
    if (當前音韻地位.屬於('莊組 仙韻')) {
      const 山or刪 = 當前音韻地位.屬於('入聲') ? '刪' : '山';
      當前音韻地位 = 當前音韻地位.調整(`${山or刪}韻 二等`); // 韻鏡無法區分
    }

    t.true(
      recovered音韻地位.等於(當前音韻地位),
      `音韻地位 ${recovered音韻地位.描述} recovered from ${當前韻鏡位置.描述} does not equal to the original 音韻地位 ${當前音韻地位.描述}`,
    );
  }
});

test('測試基本反切', t => {
  const 反切上字音韻地位 = 音韻地位.from描述('端開一登入'); // 德
  const 反切下字音韻地位 = 音韻地位.from描述('匣一東平'); // 紅
  const 被切字音韻地位 = 音韻地位.from描述('端一東平'); // 東

  const 反切上字韻鏡位置 = 音韻地位2韻鏡位置(反切上字音韻地位);
  const 反切下字韻鏡位置 = 音韻地位2韻鏡位置(反切下字音韻地位);

  // 橫推直看
  const { 右位: 上字右位 } = 反切上字韻鏡位置;
  const { 轉號: 下字轉號, 上位: 下字上位 } = 反切下字韻鏡位置;
  const computed被切字韻鏡位置 = new 韻鏡位置(下字轉號, 下字上位, 上字右位);
  const computed被切字音韻地位 = computed被切字韻鏡位置.to音韻地位();

  t.true(
    被切字音韻地位.等於(computed被切字音韻地位),
    `被切字音韻地位應該等於計算出的被切字音韻地位, but the original is ${被切字音韻地位.描述} and the computed is ${computed被切字音韻地位.描述}`,
  );
});
